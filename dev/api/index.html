<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Autologistic.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Autologistic.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../Background/">Background</a></li><li><a class="toctext" href="../Design/">Design of the Package</a></li><li><a class="toctext" href="../BasicUsage/">Basic Usage</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Types-and-Constructors-1">Types and Constructors</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/kramsretlow/Autologistic.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#Autologistic.ALRsimple"><code>Autologistic.ALRsimple</code></a></li><li><a href="#Autologistic.ALRsimple-Tuple{LinPredUnary,SimplePairwise}"><code>Autologistic.ALRsimple</code></a></li><li><a href="#Autologistic.ALRsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,2}, Array{Float64,3}}}"><code>Autologistic.ALRsimple</code></a></li><li><a href="#Autologistic.ALfit"><code>Autologistic.ALfit</code></a></li><li><a href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a></li><li><a href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a></li><li><a href="#Autologistic.ALsimple-Tuple{FullUnary,SimplePairwise}"><code>Autologistic.ALsimple</code></a></li><li><a href="#Autologistic.ALsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,1}, Array{Float64,2}}}"><code>Autologistic.ALsimple</code></a></li><li><a href="#Autologistic.AbstractAutologisticModel"><code>Autologistic.AbstractAutologisticModel</code></a></li><li><a href="#Autologistic.AbstractPairwiseParameter"><code>Autologistic.AbstractPairwiseParameter</code></a></li><li><a href="#Autologistic.AbstractUnaryParameter"><code>Autologistic.AbstractUnaryParameter</code></a></li><li><a href="#Autologistic.CenteringKinds"><code>Autologistic.CenteringKinds</code></a></li><li><a href="#Autologistic.FullPairwise"><code>Autologistic.FullPairwise</code></a></li><li><a href="#Autologistic.SamplingMethods"><code>Autologistic.SamplingMethods</code></a></li><li><a href="#Autologistic.fullPMF-Tuple{AbstractAutologisticModel}"><code>Autologistic.fullPMF</code></a></li><li><a href="#Autologistic.sample"><code>Autologistic.sample</code></a></li></ul><h2><a class="nav-anchor" id="Types-and-Constructors-1" href="#Types-and-Constructors-1">Types and Constructors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALRsimple" href="#Autologistic.ALRsimple"><code>Autologistic.ALRsimple</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ALRsimple</code></pre><p>An autologistic regression model with &quot;simple smoothing&quot;:  the unary parameter is of type <code>LinPredUnary</code>, and the pairwise parameter is of type <code>SimplePairwise</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALRsimple_type.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALRsimple-Tuple{LinPredUnary,SimplePairwise}" href="#Autologistic.ALRsimple-Tuple{LinPredUnary,SimplePairwise}"><code>Autologistic.ALRsimple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ALRsimple(
    unary::LinPredUnary,
    pairwise::SimplePairwise;
    Y::Union{Nothing,&lt;:VecOrMat}=nothing,
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;), 
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:size(unary,1)]
)</code></pre><p>Constructs an <code>ALRsimple</code> autologistic regression model, with unary part <code>unary</code> and pairwise part <code>pairwise</code>.</p><p><strong>Keyword arguments</strong></p><p><strong><code>Y</code></strong> is the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</p><p><strong><code>centering</code></strong> controls what form of centering to use.</p><p><strong><code>coding</code></strong> determines the numeric coding of the dichotomous responses. </p><p><strong><code>labels</code></strong> is a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</p><p><strong><code>coordinates</code></strong> is an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. Default is to set all coordinates to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; u = LinPredUnary(rand(10,3));
julia&gt; p = SimplePairwise(Graph(10,20));
julia&gt; model = ALRsimple(u, p, Y = rand([-2, 3], 10))
Autologistic regression model of type ALRsimple with parameter vector [β; λ].
Fields:
  responses    10×1 Bool array
  unary        10×1 LinPredUnary with fields:
                 X  10×3×1 array (covariates)
                 β  3-element vector (regression coefficients)
  pairwise     10×10×1 SimplePairwise with fields:
                 λ      [0.0] (association parameter)
                 G      the graph (10 vertices, 20 edges)
                 count  1 (the number of observations)
                 A      10×10 SparseMatrixCSC (the adjacency matrix)
  centering    none
  coding       (-1, 1)
  labels       (&quot;low&quot;, &quot;high&quot;)
  coordinates  10-element vector of Tuple{Float64,Float64}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALRsimple_type.jl#L34-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALRsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,2}, Array{Float64,3}}}" href="#Autologistic.ALRsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,2}, Array{Float64,3}}}"><code>Autologistic.ALRsimple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ALRsimple(
    graph::SimpleGraph{Int}, 
    X::Float2D3D; 
    Y::VecOrMat=Array{Bool,2}(undef,nv(graph),size(X,3)),
    β::Vector{Float64}=zeros(size(X,2)),
    λ::Float64=0.0, 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:nv(graph)]
)</code></pre><p>Constructs an <code>ALRsimple</code> autologistic regression model from a <code>graph</code> and an <code>X</code> array of predictors. Use <code>Lightgraphs.jl</code> functions to make the graph. <code>X</code> is n×p×m, where n is the number of vertices in the graph, p is the number of predictors, and m is the number of  (multivariate) observations.  If m == 1, <code>X</code> can be 2D.</p><p><strong>Keyword arguments</strong></p><p><strong><code>Y</code></strong> is the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</p><p><strong><code>β</code></strong> is the regression coefficients.</p><p><strong><code>λ</code></strong> is the association parameter.</p><p><strong><code>centering</code></strong> controls what form of centering to use.</p><p><strong><code>coding</code></strong> determines the numeric coding of the dichotomous responses. </p><p><strong><code>labels</code></strong> is a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</p><p><strong><code>coordinates</code></strong> is an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. Default is to set all coordinates to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = ALRsimple(Graph(10,20), rand(10,3), β=[0.5, 0.75, 1.0], λ=1.1)
Autologistic regression model of type ALRsimple with parameter vector [β; λ].
    Fields:
      responses    10×1 Bool array
      unary        10×1 LinPredUnary with fields:
                     X  10×3×1 array (covariates)
                     β  3-element vector (regression coefficients)
      pairwise     10×10×1 SimplePairwise with fields:
                     λ      [1.1] (association parameter)
                     G      the graph (10 vertices, 20 edges)
                     count  1 (the number of observations)
                     A      10×10 SparseMatrixCSC (the adjacency matrix)
      centering    none
      coding       (-1, 1)
      labels       (&quot;low&quot;, &quot;high&quot;)
      coordinates  10-element vector of Tuple{Float64,Float64}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALRsimple_type.jl#L101-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALfit" href="#Autologistic.ALfit"><code>Autologistic.ALfit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ALfit</code></pre><p>A type to hold estimation output for autologistic models.  Fitting functions return an  object of this type.</p><p>Depending on the fitting method, some fields might not be set.  Fields that are not used are set to <code>nothing</code> or to zero-dimensional arrays.  The fields are:</p><ul><li><code>estimate</code>: A vector of parameter estimates.</li><li><code>se</code>: A vector of standard errors for the estimates.</li><li><code>pvalues</code>: A vector of p-values for testing the null hypothesis that the parameters equal zero (one-at-a time hypothesis tests).</li><li><code>CIs</code>: A vector of 95% confidence intervals for the parameters (a vector of 2-tuples).</li><li><code>optim</code>: the output of the call to <code>optimize</code> used to get the estimates.</li><li><code>Hinv</code> (used by <code>fit_ml!</code>): The inverse of the Hessian matrix of the objective function,  evaluated at the estimate.</li><li><code>nboot</code> (<code>fit_pl!</code>): number of bootstrap samples to use for error estimation.</li><li><code>kwargs</code> (<code>fit_pl!</code>): holds extra keyword arguments passed in the call to the fitting function.</li><li><code>bootsamples</code> (<code>fit_pl!</code>): the bootstrap samples.</li><li><code>bootestimates</code> (<code>fit_pl!</code>): the bootstrap parameter estimates.</li><li><code>convergence</code>: either a Boolean indicating optimization convergence ( for <code>fit_ml!</code>), or a vector of such values for the optimizations done to estimate bootstrap replicates.</li></ul><p>The empty constructor <code>ALfit()</code> will initialize an object with all fields empty, so the needed fields can be filled afterwards.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALfit_type.jl#L1-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALsimple" href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ALsimple</code></pre><p>An autologistic model with a <code>FullUnary</code> unary parameter type and a <code>SimplePairwise</code> pairwise parameter type.   This model has the maximum number of unary parameters  (one parameter per variable per observation), and a single association parameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALsimple_type.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALsimple" href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ALsimple(graph::SimpleGraph{Int}, count::Int=1; ...)</code></pre><p>Construct an <code>ALsimple</code> autologistic model from a <code>graph</code>, with <code>count</code> undefined observations.  Keyword arguments are the same as the  <code>ALsimple(graph::SimpleGraph{Int}, alpha::Float1D2D; ...)</code> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; g = Graph(10,20);
julia&gt; model1 = ALsimple(g);
julia&gt; model2 = ALsimple(g, 4);
julia&gt; size(model1.responses)
(10, 1)

julia&gt; size(model2.responses)
(10, 4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALsimple_type.jl#L165-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALsimple-Tuple{FullUnary,SimplePairwise}" href="#Autologistic.ALsimple-Tuple{FullUnary,SimplePairwise}"><code>Autologistic.ALsimple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ALsimple(
    unary::FullUnary, 
    pairwise::SimplePairwise; 
    Y::Union{Nothing,&lt;:VecOrMat}=nothing, 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;), 
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:size(unary,1)]
)</code></pre><p>Constructs an <code>ALsimple</code> autologistic model with unary part <code>unary</code> and pairwise part <code>pairwise</code>.</p><p><strong>Keyword arguments</strong></p><p><strong><code>Y</code></strong> is the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</p><p><strong><code>centering</code></strong> controls what form of centering to use.</p><p><strong><code>coding</code></strong> determines the numeric coding of the dichotomous responses. </p><p><strong><code>labels</code></strong> is a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</p><p><strong><code>coordinates</code></strong> is an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. Default is to set all coordinates to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; u = FullUnary(rand(10));
julia&gt; p = SimplePairwise(Graph(10,20));
julia&gt; model = ALsimple(u, p)
Autologistic model of type ALsimple with parameter vector [α; λ].
Fields:
  responses    10×1 Bool array
  unary        10×1 FullUnary with fields:
                 α  10×1 array (unary parameter values)
  pairwise     10×10×1 SimplePairwise with fields:
                 λ      [0.0] (association parameter)
                 G      the graph (10 vertices, 20 edges)
                 count  1 (the number of observations)
                 A      10×10 SparseMatrixCSC (the adjacency matrix)
  centering    none
  coding       (-1, 1)
  labels       (&quot;low&quot;, &quot;high&quot;)
  coordinates  10-element vector of Tuple{Float64,Float64}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALsimple_type.jl#L35-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.ALsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,1}, Array{Float64,2}}}" href="#Autologistic.ALsimple-Tuple{SimpleGraph{Int64},Union{Array{Float64,1}, Array{Float64,2}}}"><code>Autologistic.ALsimple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ALsimple(
    graph::SimpleGraph{Int}, 
    alpha::Float1D2D; 
    Y::VecOrMat=Array{Bool,2}(undef,nv(graph),size(alpha,2)), 
    λ::Float64=0.0, 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:nv(graph)]
)</code></pre><p>Constructs an <code>ALsimple</code> autologistic model from a <code>graph</code> and unary parameter values <code>alpha</code>.</p><p><strong>Keyword arguments</strong></p><p><strong><code>Y</code></strong> is the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</p><p><strong><code>λ</code></strong> is the association parameter.</p><p><strong><code>centering</code></strong> controls what form of centering to use.</p><p><strong><code>coding</code></strong> determines the numeric coding of the dichotomous responses. </p><p><strong><code>labels</code></strong> is a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</p><p><strong><code>coordinates</code></strong> is an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. Default is to set all coordinates to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = ALsimple(Graph(10,20), rand(10))
Autologistic model of type ALsimple with parameter vector [α; λ].
Fields:
  responses    10×1 Bool array
  unary        10×1 FullUnary with fields:
                 α  10×1 array (unary parameter values)
  pairwise     10×10×1 SimplePairwise with fields:
                 λ      [0.0] (association parameter)
                 G      the graph (10 vertices, 20 edges)
                 count  1 (the number of observations)
                 A      10×10 SparseMatrixCSC (the adjacency matrix)
  centering    none
  coding       (-1, 1)
  labels       (&quot;low&quot;, &quot;high&quot;)
  coordinates  10-element vector of Tuple{Float64,Float64}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/ALsimple_type.jl#L101-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.AbstractAutologisticModel" href="#Autologistic.AbstractAutologisticModel"><code>Autologistic.AbstractAutologisticModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractAutologisticModel</code></pre><p>Abstract type representing autologistic models. All concrete subtypes should have the following fields:</p><ul><li><code>responses::Array{Bool,2}</code> – The binary observations. Rows are for nodes in the    graph, and columns are for independent (vector) observations.  It is a 2D array even if    there is only one observation.</li><li><code>unary&lt;:AbstractUnaryParameter</code> – Specifies the unary part of the model.</li><li><code>pairwise&lt;:AbstractPairwiseParameter</code>  – Specifies the pairwise part of the model    (including the graph).</li><li><code>centering&lt;:CenteringKinds</code> – Specifies the form of centering used, if any.</li><li><code>coding::Tuple{T,T} where T&lt;:Real</code> – Gives the numeric coding of the responses.</li><li><code>labels::Tuple{String,String}</code> – Provides names for the high and low states.</li><li><code>coordinates&lt;:SpatialCoordinates</code> – Provides 2D or 3D coordinates for each vertex in    the graph.</li></ul><p>This type has the following functions defined, considered part of the type&#39;s interface. They cover most operations one will want to perform.  Concrete subtypes should not have to define custom overrides unless more specialized or efficient algorithms exist for the  subtype.</p><ul><li><code>getparameters</code> and <code>setparameters!</code></li><li><code>getunaryparameters</code> and <code>setunaryparameters!</code></li><li><code>getpairwiseparameters</code> and <code>setpairwiseparameters!</code></li><li><code>centeringterms</code></li><li><code>negpotential</code>, <code>pseudolikelihood</code>, and <code>loglikelihood</code></li><li><code>fullPMF</code>, <code>marginalprobabilities</code>, and <code>conditionalprobabilities</code></li><li><code>fit_pl!</code> and <code>fit_ml!</code></li><li><code>sample</code> and <code>oneboot</code></li><li><code>showfields</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M)
ALsimple{CenteringKinds,Int64,Nothing}
julia&gt; isa(M, AbstractAutologisticModel)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/abstractautologisticmodel_type.jl#L1-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.AbstractPairwiseParameter" href="#Autologistic.AbstractPairwiseParameter"><code>Autologistic.AbstractPairwiseParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPairwiseParameter</code></pre><p>Abstract type representing the pairwise part of an autologistic regression model.</p><p>All concrete subtypes should have the following fields:</p><ul><li><code>G::SimpleGraph{Int}</code> – The graph for the model.</li><li><code>count::Int</code>  – The number of observations.</li></ul><p>In addition to <code>getindex()</code> and <code>setindex!()</code>, any concrete subtype  <code>P&lt;:AbstractPairwiseParameter</code> should also have the following methods defined:</p><ul><li><code>getparameters(P)</code>, returning a Vector{Float64}</li><li><code>setparameters!(P, newpar::Vector{Float64})</code> for setting parameter values.</li></ul><p>Note that indexing is performance-critical and should be implemented carefully in  subtypes.  </p><p>The intention is that each subtype should implement a different way of parameterizing the association matrix. The way parameters are stored and values computed is up to the subtypes. </p><p>This type inherits from <code>AbstractArray{Float64, 3}</code>.  The third index is to allow for  multiple observations. <code>P[:,:,r]</code> should return the association matrix of the rth observation in an appropriate subtype of AbstractMatrix.  It is not intended that the third  index will be used for range or vector indexing like <code>P[:,:,1:5]</code> (though this may work  due to AbstractArray fallbacks). </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M.pairwise)
SimplePairwise
julia&gt; isa(M.pairwise, AbstractPairwiseParameter)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/abstractpairwiseparameter_type.jl#L1-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.AbstractUnaryParameter" href="#Autologistic.AbstractUnaryParameter"><code>Autologistic.AbstractUnaryParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractUnaryParameter</code></pre><p>Abstract type representing the unary part of an autologistic regression model.</p><p>This type inherits from AbstractArray{Float64, 2}. The first dimension is for vertices/variables in the graph, and the second dimension is for observations.  It is two-dimensional even if there is only one observation. </p><p>Implementation details are left to concrete subtypes, and will depend on how the unary terms are parametrized.  Note that indexing is performance-critical.</p><p>Concrete subtypes should implement <code>getparameters</code>, <code>setparameters!</code>, and <code>showfields</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M.unary)
FullUnary
julia&gt; isa(M.unary, AbstractUnaryParameter)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/abstractunaryparameter_type.jl#L5-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.CenteringKinds" href="#Autologistic.CenteringKinds"><code>Autologistic.CenteringKinds</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CenteringKinds</code></pre><p>An enumeration to facilitate choosing a form of centering for the model.  Available choices are: </p><ul><li><code>none</code>: no centering (centering adjustment equals zero).</li><li><code>expectation</code>: the centering adjustment is the expected value of the response under the   assumption of independence (this is what has been used in the &quot;centered autologistic    model&quot;).</li><li><code>onehalf</code>: a constant value of centering adjustment equal to 0.5.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.FullPairwise" href="#Autologistic.FullPairwise"><code>Autologistic.FullPairwise</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FullPairwise</code></pre><p>A type representing an association matrix with a &quot;saturated&quot; parametrization–one parameter  for each edge in the graph.</p><p>In this type, the association matrix for each observation is a symmetric matrix with the  same pattern of nonzeros as the graph&#39;s adjacency matrix, but with arbitrary values in those locations. The package convention is to provide parameters as a vector of <code>Float64</code>.  So  <code>getparameters</code> and <code>setparameters!</code> use a vector of <code>ne(G)</code> values that correspond to the  nonzero locations in the upper triangle of the adjacency matrix, in the same (lexicographic) order as <code>edges(G)</code>.</p><p>The association matrix is stored as a <code>SparseMatrixCSC{Float64,Int64}</code> in the field Λ.</p><p>As with <code>SimplePairwise</code>, the association matrix can not be different for different observations.  So while <code>size</code> returns a 3-dimensional result, the third index is ignored when accessing the array&#39;s elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/fullpairwise_type.jl#L13-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.SamplingMethods" href="#Autologistic.SamplingMethods"><code>Autologistic.SamplingMethods</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SamplingMethods</code></pre><p>An enumeration to facilitate choosing a method for sampling. Available choices are:</p><ul><li><code>Gibbs</code>  TODO</li><li><code>perfect_bounding_chain</code>  TODO</li><li><code>perfect_reuse_samples</code>  TODO </li><li><code>perfect_reuse_seeds</code>  TODO</li><li><code>perfect_read_once</code>  TODO </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L10">source</a></section><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.fullPMF-Tuple{AbstractAutologisticModel}" href="#Autologistic.fullPMF-Tuple{AbstractAutologisticModel}"><code>Autologistic.fullPMF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fullPMF(M::AbstractAutologisticModel; indices=1:size(M.unary,2), force::Bool=false)</code></pre><p>Compute the PMF of an AbstractAutologisticModel, and return a <code>NamedTuple</code> <code>(:table, :partition)</code>.</p><p>For an AbstractAutologisticModel with <span>$n$</span> variables and <span>$m$</span> observations, <code>:table</code> is a <span>$2^n×(n+1)×m$</span> array of <code>Float64</code>. Each page of the 3D array holds a probability table for  an observation.  Each row of the table holds a specific configuration of the responses, with the corresponding probability in the last column.  In the <span>$m=1$</span> case,  <code>:table</code> is a 2D  array.</p><p>Output <code>:partition</code> is a vector of normalizing constant (a.k.a. partition function) values. In the <span>$m=1$</span> case, it is a scalar <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: an autologistic model.</li><li><code>indices</code>: indices of specific observations from which to obtain the output. By  default, all observations are used.</li><li><code>force</code>: calling the function with <span>$n&gt;20$</span> will throw an error unless  <code>force=true</code>. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALRsimple(Graph(3,0),ones(3,1));
julia&gt; pmf = fullPMF(M);
julia&gt; pmf.table
8×4 Array{Float64,2}:
 -1.0  -1.0  -1.0  0.125
 -1.0  -1.0   1.0  0.125
 -1.0   1.0  -1.0  0.125
 -1.0   1.0   1.0  0.125
  1.0  -1.0  -1.0  0.125
  1.0  -1.0   1.0  0.125
  1.0   1.0  -1.0  0.125
  1.0   1.0   1.0  0.125
julia&gt; pmf.partition
 8.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/abstractautologisticmodel_type.jl#L254-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.sample" href="#Autologistic.sample"><code>Autologistic.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(
    M::AbstractAutologisticModel, 
    k::Int = 1;
    method::SamplingMethods = Gibbs,
    indices = 1:size(M.unary,2), 
    average::Bool = false, 
    config = nothing, 
    burnin::Int = 0,
    verbose::Bool = false
)</code></pre><p>Draws <code>k</code> random samples from autologistic model <code>M</code>, and either returns the samples  themselves, or the estimated probabilities of observing the &quot;high&quot; level at each vertex.</p><p>If the model has more than one observation, then <code>k</code> samples are drawn for each observation&#39;s parameter settings. To restrict the samples to a subset of observations, use argument <code>indices</code>. </p><p>For a model <code>M</code> with <code>n</code> vertices in its graph:</p><ul><li>When <code>average=false</code>, the return value is <code>n</code> × <code>length(indices)</code> × <code>k</code>, with singleton   dimensions dropped. </li><li>When <code>average=true</code>, the return value is <code>n</code>  × <code>length(indices)</code>, with singleton   dimensions dropped.</li></ul><p><strong>Keyword Arguments</strong></p><p><strong><code>method</code></strong> is a member of the enum <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a>, specifying which sampling method will be used.  The default uses Gibbs sampling.  Where feasible, it is recommended  to use one of the perfect sampling alternatives. See <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a> for more.</p><p><strong><code>indices</code></strong> gives the indices of the observation to use for sampling. The default is all indices, in which case each sample is of the same size as <code>M.responses</code>. </p><p><strong><code>average</code></strong> controls the form of the output. When <code>average=true</code>, the return value is the  proportion of &quot;high&quot; samples at each vertex. (Note that this is <strong>not</strong> actually the arithmetic average of the samples, unless the coding is (0,1). Rather, it is an estimate of  the probability of getting a &quot;high&quot; outcome.)  When <code>average=false</code>, the full set of samples is returned. </p><p><strong><code>config</code></strong> allows a starting configuration of the random variables to be provided. Only used if <code>method=Gibbs</code>. Any vector of the correct length, with two unique values, can be  used as <code>config</code>. By default a random configuration is used.</p><p><strong><code>burnin</code></strong> specifies the number of initial samples to discard from the results.  Only used if <code>method=Gibbs</code>.</p><p><strong><code>skip</code></strong> specifies how many samples to throw away between returned samples.  Only used  if <code>method=Gibbs</code>. </p><p><strong><code>verbose</code></strong> controls output to the console.  If <code>true</code>, intermediate information about  sampling progress is printed to the console. Otherwise no output is shown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; M.coding = (-2,3);
julia&gt; r = sample(M,10);
julia&gt; size(r)
(4, 10)
julia&gt; sort(unique(r))
2-element Array{Float64,1}:
 -2.0
  3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/2dbcd17ecf4afc8ac77ddafe6ce3a3598340c958/src/abstractautologisticmodel_type.jl#L476-L542">source</a></section><footer><hr/><a class="previous" href="../Examples/"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
