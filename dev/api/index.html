<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Autologistic.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Autologistic.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../Background/">Background</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"><li><a class="toctext" href="#Types-and-Constructors-1">Types and Constructors</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul><a class="edit-page" href="https://github.com/kramsretlow/Autologistic.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Types-and-Constructors-1" href="#Types-and-Constructors-1">Types and Constructors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.AbstractAutologisticModel" href="#Autologistic.AbstractAutologisticModel"><code>Autologistic.AbstractAutologisticModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractAutologisticModel</code></pre><p>Abstract type representing autologistic models.  This type has methods defined for most operations one will want to perform, so that concrete subtypes should not have to define too many methods unless more specialized and efficient algorithms for the specific subtype.</p><p>All concrete subtypes should have the following fields:</p><ul><li><code>responses::Array{Bool,2}</code> – The binary observations. Rows are for nodes in the    graph, and columns are for independent (vector) observations.  It is a 2D array even if    there is only one observation.</li><li><code>unary&lt;:AbstractUnaryParameter</code> – Specifies the unary part of the model.</li><li><code>pairwise&lt;:AbstractPairwiseParameter</code>  – Specifies the pairwise part of the model    (including the graph).</li><li><code>centering&lt;:CenteringKinds</code> – Specifies the form of centering used, if any.</li><li><code>coding::Tuple{T,T} where T&lt;:Real</code> – Gives the numeric coding of the responses.</li><li><code>labels::Tuple{String,String}</code> – Provides names for the high and low states.</li><li><code>coordinates&lt;:SpatialCoordinates</code> – Provides 2D or 3D coordinates for each vertex in    the graph (or <code>nothing</code> if no coordinates).</li></ul><p>The following functions are defined for the abstract type, and are considered part of the  type&#39;s interface (in this list, <code>M</code> of type inheriting from <code>AbstractAutologisticModel</code>).</p><ul><li><code>getparameters(M)</code> and <code>setparameters!(M, newpars::Vector{Float64})</code></li><li><code>getunaryparameters(M)</code> and <code>setunaryparameters!(M, newpars::Vector{Float64})</code></li><li><code>getpairwiseparameters(M)</code> and <code>setpairwiseparameters!(M, newpars::Vector{Float64})</code></li><li><code>makecoded(M, Y)</code></li><li><code>centeringterms(M, kind::Union{Nothing,CenteringKinds})</code></li><li><code>pseudolikelihood(M)</code></li><li><code>negpotential(M)</code></li><li><code>fullPMF(M; indices, force::Bool)</code></li><li><code>marginalprobabilities(M; indices, force::Bool)</code></li><li><code>conditionalprobabilities(M; vertices, indices)</code></li><li><code>sample(M, k::Int, method::SamplingMethods, indices::Int, average::Bool, start,    burnin::Int, verbose::Bool)</code></li></ul><p>The <code>sample()</code> function is a wrapper for a variety of random sampling algorithms enumerated in <code>SamplingMethods</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M)
ALsimple{CenteringKinds,Int64,Nothing}
julia&gt; isa(M, AbstractAutologisticModel)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/da311af46d869ceccfcb05077d79e0fdf98e7a34/src/abstractautologisticmodel_type.jl#L1-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.SamplingMethods" href="#Autologistic.SamplingMethods"><code>Autologistic.SamplingMethods</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SamplingMethods</code></pre><p>An enumeration to facilitate choosing a method for sampling. Available choices are:</p><ul><li><code>Gibbs</code>  TODO</li><li><code>perfect_bounding_chain</code>  TODO</li><li><code>perfect_reuse_samples</code>  TODO </li><li><code>perfect_reuse_seeds</code>  TODO</li><li><code>perfect_read_once</code>  TODO</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L10">source</a></section><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.fullPMF" href="#Autologistic.fullPMF"><code>Autologistic.fullPMF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fullPMF(M::AbstractAutologisticModel; indices=1:size(M.unary)[2], force::Bool=false)</code></pre><p>Compute the PMF of an AbstractAutologisticModel, and return a <code>NamedTuple</code> <code>(:table, :partition)</code>.</p><p>For an AutologisticModel with <span>$n$</span> variables and <span>$m$</span> observations, <code>:table</code> is a <span>$2^n×(n+1)×m$</span>  array of <code>Float64</code>. Each page of the 3D array holds a probability table for an observation.   Each row of the table holds a specific configuration of the responses, with the  corresponding probability in the last column.  In the <span>$m=1$</span> case,  <code>:table</code> is a 2D array.</p><p>Output <code>:partition</code> is a vector of normalizing constant (a.k.a. partition function) values. In the <span>$m=1$</span> case, it is a scalar <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: an autologistic model.</li><li><code>indices</code>: indices of specific observations from which to obtain the output. By  default, all observations are used.</li><li><code>force</code>: calling the function with <span>$n&gt;20$</span> will throw an error unless  <code>force=true</code>. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALRsimple(Graph(3,0),ones(3,1));
julia&gt; pmf = fullPMF(M);
julia&gt; pmf.table
8×4 Array{Float64,2}:
 -1.0  -1.0  -1.0  0.125
 -1.0  -1.0   1.0  0.125
 -1.0   1.0  -1.0  0.125
 -1.0   1.0   1.0  0.125
  1.0  -1.0  -1.0  0.125
  1.0  -1.0   1.0  0.125
  1.0   1.0  -1.0  0.125
  1.0   1.0   1.0  0.125
julia&gt; pmf.partition
 8.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/da311af46d869ceccfcb05077d79e0fdf98e7a34/src/abstractautologisticmodel_type.jl#L163-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Autologistic.sample" href="#Autologistic.sample"><code>Autologistic.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(
    M::AbstractAutologisticModel, 
    k::Int = 1;
    method::SamplingMethods = Gibbs,
    index::Int = 1, 
    average::Bool = false, 
    start = nothing, 
    burnin::Int = 0,
    verbose::Bool = false
)</code></pre><p>Draws <code>k</code> random samples from autologistic model <code>M</code>. For a model <code>M</code> with <code>n</code>  vertices in its graph, the return value is an <code>Array{Float64,1}</code> of length <code>n</code> when  <code>average=true</code>, and an <code>n×k</code> <code>Array{Float64,2}</code> when <code>average=false</code>.</p><p><strong>Keyword Arguments</strong></p><p><strong><code>method</code></strong> is a member of the enum <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a>, specifying which sampling method will be used.  The default uses Gibbs sampling.  Where feasible, it is recommended  to use one of the perfect sampling alternatives. See <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a> for more.</p><p><strong><code>index</code></strong> gives the index of the observation to use for sampling. </p><p><strong><code>average</code></strong> controls whether the return value is the proportion of &quot;high&quot; samples at each  (when <code>average=true</code>) or the full set of samples (when <code>average=false</code>). Note that when the coding is not (0,1), the the return value is the estimated probability of getting a &quot;high&quot; outcome, <strong>not</strong> the arithmetic average of the samples.</p><p><strong><code>start</code></strong> allows a starting configuration of the random variables to be provided. Only used if <code>method=Gibbs</code>. Any vector with two unique values can be used as <code>start</code>.</p><p><strong><code>burnin</code></strong> specifies the number of initial samples to discard from the results.  Only used if <code>method=Gibbs</code>.</p><p><strong><code>verbose</code></strong> controls output to the console.  If <code>true</code>, intermediate information about  sampling progress is printed to the console. Otherwise no output is shown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; M.coding = (-2,3);
julia&gt; r = sample(M,10);
julia&gt; size(r)
(4, 10)
julia&gt; unique(r)
2-element Array{Float64,1}:
  3.0
 -2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/da311af46d869ceccfcb05077d79e0fdf98e7a34/src/abstractautologisticmodel_type.jl#L314-L364">source</a></section><footer><hr/><a class="previous" href="../Examples/"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
