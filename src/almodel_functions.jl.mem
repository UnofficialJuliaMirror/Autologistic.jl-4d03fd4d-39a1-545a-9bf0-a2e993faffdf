        - # A fcn to convert Boolean responses into coded values.
        - # Returns a 2D array of Float64.  If Y is not supplied, use the responses stored
        - # in the 1st argument.
        - function makecoded(M::ALmodel, Y=nothing)
        -     if Y==nothing
        -         Y = M.responses
        -     else
     1360         Y = makebool(Y)
        -     end
        -     lo = M.coding[1]
        -     hi = M.coding[2]
        0     n, m = size(Y)
        -     out = Array{Float64,2}(undef, n, m)
     9984     for j = 1:m
        0         for i = 1:n
        0             out[i,j] = Y[i,j] ? hi : lo
        -         end
        -     end
        0     return out
        - end
        - 
        - 
        - # === centering adjustment =====================================================
        - # centering_adjustment(M) returns an Array{Float64,2} of the same dimension as 
        - # M.unary, giving the centering adjustments for ALmodel M.
        - # centering_adjustment(M,kind) returns the centering adjustment that would be 
        - #   if centering were of type kind.
        - # TODO: consider performance implications of calculating this each time instead
        - # of storing the value.
        - function centering_adjustment(M::ALmodel, kind::Union{Nothing,CenteringKinds}=nothing) 
        0     k = kind==nothing ? M.centering : kind
        0     if k == none
     9984         return fill(0.0, size(M.unary))
        0     elseif k == onehalf
        0         return fill(0.5, size(M.unary))
        0     elseif k == expectation
        -         lo, hi = M.coding
        0         α = M.unary[:,:] 
        0         num = lo*exp.(lo*α) + hi*exp.(hi*α)
        0         denom = exp.(lo*α) + exp.(hi*α)
        0         return num./denom
        -     else 
        0         error("centering kind not recognized")
        -     end
        - end
        - 
        - 
        - # === pseudolikelihood =========================================================
        - # pseudolikelihood(M) computes the negative log pseudolikelihood for the given 
        - # ALmodel with its responses.  Returns a Float64.
        - function pseudolikelihood(M::ALmodel)
        -     out = 0.0
        -     Y = makecoded(M)
        -     mu = centering_adjustment(M)
        -     lo, hi = M.coding
        - 
        -     # Loop through replicates
        -     for j = 1:size(Y)[2]
        -         y = Y[:,j];                     #-Current replicate's observations.
        -         α = M.unary[:,j]                #-Current replicate's unary parameters.
        -         μ = mu[:,j]                     #-Current replicate's centering terms.
        -         Λ = M.pairwise[:,:,j]           #-Current replicate's assoc. matrix.
        -         s = α + Λ*(y - μ)               #-(λ-weighted) neighbour sums + unary.
        -         logPL = sum(y.*s - log.(exp.(lo*s) + exp.(hi*s)))
        -         out = out - logPL               #-Subtract this rep's log PL from total.
        -     end
        - 
        -     return out
        - 
        - end
        - 
        - 
        - # === negpotential function ====================================================
        - # negpotential(M) returns an m-vector of Float64 negpotential values, where 
        - # m is the number of replicate observations found in M.responses.
        - # TODO: clean up for allocations/speed. Based on experience with sample(), might
        - #       want to loop explicitly.
        - function negpotential(M::ALmodel)
        -     Y = makecoded(M)
        -     m = size(Y,2)
        -     out = Array{Float64}(undef, m)
        -     α = M.unary[:,:]
        -     μ = centering_adjustment(M)
        -     for j = 1:m
        -         Λ = M.pairwise[:,:,j]
        -         out[j] = Y[:,j]'*α[:,j] - Y[:,j]'*Λ*μ[:,j]  + Y[:,j]'*Λ*Y[:,j]/2
        -     end
        -     return out
        - end
        - 
        - 
        - # === fullPMF ==================================================================
        - """
        -     fullPMF(M::ALmodel; replicates=nothing, force::Bool=false)
        - 
        - Compute the PMF of an ALmodel, and return a `NamedTuple` `(:table, :partition)`.
        - 
        - For an ALmodel with ``n`` observations and ``m`` replicates, `:table` is a ``2^n×(n+1)×m`` 
        - array of `Float64`. Each page of the 3D array holds a probability table for a replicate.  
        - Each row of the table holds a specific configuration of the responses, with the 
        - corresponding probability in the last column.  In the ``m=1`` case,  `:table` is a 2D array.
        - 
        - Output `:partition` is a vector of normalizing constant (a.k.a. partition function) values.
        - In the ``m=1`` case, it is a scalar `Float64`.
        - 
        - # Arguments
        - - `M::ALmodel`: an autologistic model.
        - - `replicates=nothing`: indices of specific replicates from wich to obtain the output. By 
        -   default, all replicates are used.
        - - `force::Bool=false`: calling the function with ``n>20`` will throw an error unless 
        -   `force=true`. 
        - 
        - # Examples
        - ```jldoctest
        - julia> M = ALRsimple(Graph(3,0),ones(3,1));
        - julia> pmf = fullPMF(M);
        - julia> pmf.table
        - 8×4 Array{Float64,2}:
        -  -1.0  -1.0  -1.0  0.125
        -  -1.0  -1.0   1.0  0.125
        -  -1.0   1.0  -1.0  0.125
        -  -1.0   1.0   1.0  0.125
        -   1.0  -1.0  -1.0  0.125
        -   1.0  -1.0   1.0  0.125
        -   1.0   1.0  -1.0  0.125
        -   1.0   1.0   1.0  0.125
        - julia> pmf.partition
        -  8.0
        - ```
        - """
        - function fullPMF(M::ALmodel; replicates=nothing, force::Bool=false)
        -     n, m = size(M.unary)
        -     nc = 2^n
        -     if n>20 && !force
        -         error("Attempting to tabulate a PMF with more than 2^20 configurations."
        -               * "\nIf you really want to do this, set force=true.")
        -     end
        -     if replicates == nothing
        -         replicates = 1:m
        -     elseif minimum(replicates)<1 || maximum(replicates)>m 
        -         error("replicate index out of bounds")
        -     end
        -     lo = M.coding[1]
        -     hi = M.coding[2]
        -     T = zeros(nc, n+1, length(replicates))
        -     configs = zeros(nc,n)
        -     partition = zeros(m)
        -     for i in 1:n
        -         inner = [repeat([lo],Int(nc/2^i)); repeat([hi],Int(nc/2^i))]
        -         configs[:,i] = repeat(inner , 2^(i-1) )
        -     end
        -     for i in 1:length(replicates)
        -         r = replicates[i]
        -         T[:,1:n,i] = configs
        -         α = M.unary[:,r]
        -         Λ = M.pairwise[:,:,r]
        -         μ = centering_adjustment(M)[:,r]
        -         unnormalized = mapslices(v -> exp.(v'*α - v'*Λ*μ + v'*Λ*v/2), configs, dims=2)
        -         partition[i] = sum(unnormalized)
        -         T[:,n+1,i] = unnormalized / partition[i]
        -     end
        -     if length(replicates)==1
        -         T  = dropdims(T,dims=3)
        -         partition = partition[1]
        -     end
        -     return (table=T, partition=partition)
        - end
        - 
        - 
